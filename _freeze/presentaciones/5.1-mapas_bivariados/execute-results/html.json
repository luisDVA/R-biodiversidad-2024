{
  "hash": "5dc377f74fc5a51cea588332c3a1c0ea",
  "result": {
    "markdown": "---\ntitle: \"Mapas bivariados\"\nauthor: \"Gabriel Massaine Moulatlet\"\ninstitute: Instituto de Ecología, A.C.\nformat: \n  revealjs:\n    slide-number: true\n    embed-resources: true\neditor: visual\nhighlight-style: arrow-light\n---\n\n\n# Mapas bivariados\n\n## Paquetes\n\nVamos a utilizar los siguientes paquetes en R\n\n-   bivariate\n-   ggplot2\n\n## Biscale\n\n::: columns\n::: {.column width=\"20%\"}\n![](imgs/biscale.png)\n:::\n\n::: {.column width=\"80%\"}\n-   Paquete para producir mapas bivariados (i.e. dos variables en el mismo layout)\n    -   Sirve para producir leyendas bivariadas\n    -   Herramientas para classificación de datos en categorías usando diferentes técnicas\n    -   [Documentación](https://chris-prener.github.io/biscale/index.html)\n:::\n:::\n\n## Según la wikipedia..\n\n-   Mapas bivariados también son conocidos por *Mapa coropleto* o *Mapa de coropletas*\n\n> Es un tipo de mapa temático en el que las áreas se sombrean de distintos colores, frecuentemente de la misma gama cromática, que representan distintos valores de una variable estadística característica.\n\n## Dos o más variables...\n\n-   Mapas bivariados son útiles para graficar dos variables\n-   Ajuste de colores, transparencias y formas\n\n![](https://www.joshuastevens.net/images/js_finalBivariateMap.png)\n\n## Son bastante comunes para reportar resultados de elecciones\n\n![](imgs/para.png){fig-align=\"center\" fig-size=\"82%\"}\n\n## También usados para reportar indicadores socio-económicos\n\n![](imgs/dengue.png){fig-align=\"center fig-size=\"82%\"\"}\n\n## Hay otros ejemplos: colores y marcas\n\n![](imgs/tabaco.png){fig-align=\"center\" fig-size=\"82%\"}\n\n## Hay otros ejemplos: colores y area ![](imgs/happy.png){fig-align=\"center\" fig-size=\"82%\"}\n\n## Leyendas triangulares\n\n-   Tres variables [Sabatini et al. 2022](https://onlinelibrary.wiley.com/doi/full/10.1111/ddi.13158) ![](imgs/sabatini.jpg){fig-align=\"center\"}\n\n## Formatos complejos\n\n[Sabatini et al. 2022](https://onlinelibrary.wiley.com/doi/full/10.1111/ddi.13158) ![](imgs/forest.jpg){fig-align=\"center\" fig-size=\"82%\"}\n\n## Mapas RGB\n\n![](imgs/dengue3.png){fig-align=\"center\"}\n\n## Leyendas rectangulares con varias categorias\n\n[Peixoto et al. 2017](https://onlinelibrary.wiley.com/doi/abs/10.1111/geb.12561) ![](imgs/peixoto.png){fig-align=\"center\"}\n\n## Pero lo más importante es que la información esté clara\n\n-   ¿Cuál de los dos mapas transmite mejor la información? ![](imgs/dengue2.png){fig-align=\"center\"}\n\n# Producir mapas bivariados\n\n## Teoría:\n\n-   La idea central es buscar una manera de como combinar estas dos variables\n-   Escalas diferentes, número diferente de categorias etc...\n-   Mapas bivariados constan de dos pasos:\n    1.  Categorización de las variables según alguna estadística\n    2.  Preparación de una leyenda con base en una \"paleta\" de colores\n\n# 1. Categorización de variables\n\n## Pasos:\n\n-   Clasificar los datos en conteos o proporciones\n-   las funciones `cut()` y `summary()` de R base pueden ser útiles\n-   vamos usar la base de datos *iris*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(iris$Sepal.Length)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  4.300   5.100   5.800   5.843   6.400   7.900 \n```\n:::\n:::\n\n\n## \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(janitor)\n\n# Categorizar de acuerdo a los quantiles\nci = cut(iris$Sepal.Length,breaks = c(4.3,5.1,5.8,6.4, max(iris$Sepal.Length)))\n\n# Explorar los resultados\ntabyl(ci)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        ci  n     percent valid_percent\n (4.3,5.1] 40 0.266666667     0.2684564\n (5.1,5.8] 39 0.260000000     0.2617450\n (5.8,6.4] 35 0.233333333     0.2348993\n (6.4,7.9] 35 0.233333333     0.2348993\n      <NA>  1 0.006666667            NA\n```\n:::\n:::\n\n\n## la función `classIntervals()`\n\n-   Permite categorizar los datos usando varios tipos de categorización\n-   *quantile*, *jenkins*, *equal* para mencionar algunas\n-   hay que definir el numero de clases (parámetro *n*)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(classInt)\n\nclassInt::classIntervals(iris$Sepal.Length,style=\"quantile\",n=4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nstyle: quantile\n  one of 5,984 possible partitions of this variable into 4 classes\n[4.3,5.1) [5.1,5.8) [5.8,6.4) [6.4,7.9] \n       32        41        35        42 \n```\n:::\n:::\n\n\n## \n\n::: columns\n::: {.column width=\"50%\"}\n-   Luego de categorizar el vector de interés, se puede cortar con la función `cut()`\n-   Tambien se puede generar un vector con las categorías y juntarlo a los datos originales usando la función `findCols()`\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nbreaks = classInt::classIntervals(iris$Sepal.Length,style=\"quantile\",n=4)$brks\n\ncc = cut(iris$Sepal.Length, breaks = breaks)\ntabyl(cc)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        cc  n     percent valid_percent\n (4.3,5.1] 40 0.266666667     0.2684564\n (5.1,5.8] 39 0.260000000     0.2617450\n (5.8,6.4] 35 0.233333333     0.2348993\n (6.4,7.9] 35 0.233333333     0.2348993\n      <NA>  1 0.006666667            NA\n```\n:::\n:::\n\n:::\n:::\n\n## la función `findCols()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generar un vector que se pueda juntar a la tabla de datos originales\n\nfc = findCols(classInt::classIntervals(iris$Sepal.Length,style=\"quantile\",n=4))\nhead(fc)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 1 1 1 1 2\n```\n:::\n:::\n\n\n## usando el paquete `biscale`\n\n::: columns\n::: {.column width=\"50%\"}\n-   Se utliza la función `bi_class()` para generar las categorías\n-   Una de las ventajas de usar la función `bi_class()` es que hace la categorización de las dos variables elejidas de una sola vez\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(biscale)\n\ndata <- bi_class(iris, x = Sepal.Length, y = Petal.Length, style = \"quantile\", dim = 3)\nhead(data$bi_class)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1-1\" \"1-1\" \"1-1\" \"1-1\" \"1-1\" \"1-1\"\n```\n:::\n:::\n\n:::\n:::\n\n# 2. Preparación de leyenda bivariada\n\n## Preparación de una leyenda\n\n![](imgs/biva.png)\n\n## \n\n![](imgs/mix.gif)\n\n## La función `bi_legend()`\n\n-   Para ver las paletas disponibles [aquí](https://chris-prener.github.io/biscale/articles/bivariate_palettes.html)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbi_legend(pal = \"GrPink\",\n                    dim = 3,\n                    xlab = \"Sepal.Length\",\n                    ylab = \"Petal.Lenght\",\n                    size = 12)\n```\n\n::: {.cell-output-display}\n![](5.1-mapas_bivariados_files/figure-revealjs/unnamed-chunk-7-1.png){width=960}\n:::\n:::\n\n\n## El mapa bivariado\n\n1)  Vamos a ver el ejemplo del [vignette](https://chris-prener.github.io/biscale/articles/biscale.html)\n\n-   Son datos sobre el porcentaje de \"brancos\" y la ganancia en los EUA.\n-   Vamos usar las columnas `pctWhite` y `medInc` para hacer el mapa.\n-   Vamos usar 3 dimensiones y categorizar los datos usando `quantiles`\n\n## Manos a la obra!\n\n-   El mapa se construye usando ggplot\n-   Determinamos el geom como `geom_sf` y como argumento estético `fill = bi_class`\n-   El `bi_class` debe ser la categorización que hemos visto anteriormente con usando la justamente a función `bi_class()`\n-   Una de las capas del ggplot debe ser `bi_scale_fill`, donde van a poner el argumento `pal` - que es la paleta de colores y `dim` - que es el numero de categorías utilizadas para categorizar los datos.\n\n## \n\n\n::: {.cell}\n\n```{.r .cell-code .code-overflow-wrap}\nlibrary(ggplot2)\nlibrary(sf)\n\ndata <- bi_class(stl_race_income, x = pctWhite, y = medInc, style = \"quantile\", dim = 3)\n\nmap <- ggplot() +\n  geom_sf(data = data, mapping = aes(fill = bi_class), color = \"white\", size = 0.1, show.legend = FALSE) +\n  bi_scale_fill(pal = \"GrPink\", dim = 3)\n```\n:::\n\n\n## \n\n-   Después de preparar el mapa, hay que preparar la leyenda\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlegend <- bi_legend(pal = \"GrPink\",\n                    dim = 3,\n                    xlab = \"Higher % White \",\n                    ylab = \"Higher Income \",\n                    size = 8)\n```\n:::\n\n\n-   Por fin, ponerlos lado a lado usando el paquete `patchwork`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(patchwork)\n\nmap + legend\n```\n:::\n\n\n## \n\nSe juede jugar con el layout final usando la función `inset`\n\np1 + inset_element(p2, 0.6, 0.6, 1, 1) \\# left, top, right, bottom\n\n![](https://patchwork.data-imaginist.com/reference/inset_element-1.png)\n\n## \n\n![](https://chris-prener.github.io/biscale/reference/figures/biscale.002.jpeg){fig-align=\"center\"}\n\n# Como hacer mapas bivariados sin usar el paquete `biscale`\n\n## \n\n-   El tutorial de [Len Kiefer](http://lenkiefer.com/2017/04/24/bivariate-map/)\n-   Usar el paquete `classInt` para categorizar los datos\n-   Usar el esquema de colores de la leyenda para preparar el mapa\n\n![](http://lenkiefer.com/post/2017-04-24-bivariate-map_files/figure-html/04-24-2017-setup-2-1.png)\n\n## \n\n![](imgs/map.png)\n\n## \n\n-   La leyenda se hace con la función `expand_grid()` del paquete `tidyr`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyr)\n\nd=expand.grid(x=1:3,y=1:3)\nd\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x y\n1 1 1\n2 2 1\n3 3 1\n4 1 2\n5 2 2\n6 3 2\n7 1 3\n8 2 3\n9 3 3\n```\n:::\n:::\n\n\n## \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nggplot(d, aes(x,y))+\n  geom_tile(aes(alpha=x+y,fill=atan(y/x)))+\n  scale_fill_viridis_c()+\n  theme(legend.position=\"none\",\n        axis.text.y = element_blank(),\n        axis.text.x = element_blank(),\n        axis.ticks = element_blank(),\n        panel.grid.minor = element_blank(),\n        panel.grid.major = element_blank())+\n  coord_equal()\n```\n\n::: {.cell-output-display}\n![](5.1-mapas_bivariados_files/figure-revealjs/unnamed-chunk-12-1.png){width=960}\n:::\n:::\n\n\n## \n\n-   Lo importante aqui es usar el geom `geom_tile`\n-   Permite usar varios [colores](https://ggplot2.tidyverse.org/reference/geom_tile.html)\n-   Vamos jugar con los valores de `alpha` (transparencia) y `fill`\n\n## \n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(d, aes(x,y))+\n  geom_tile(aes(fill=atan(y/x)))+\n  scale_fill_viridis_c()+\n  theme(legend.position=\"none\",\n        axis.text.y = element_blank(),\n        axis.text.x = element_blank(),\n        axis.ticks = element_blank(),\n        panel.grid.minor = element_blank(),\n        panel.grid.major = element_blank())+\n  coord_equal()\n```\n\n::: {.cell-output-display}\n![](5.1-mapas_bivariados_files/figure-revealjs/unnamed-chunk-13-1.png){width=960}\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(d, aes(x,y))+\n  geom_tile(aes(fill=atan(y/x),alpha=x+y))+\n  scale_fill_viridis_c()+\n  theme(legend.position=\"none\",\n        axis.text.y = element_blank(),\n        axis.text.x = element_blank(),\n        axis.ticks = element_blank(),\n        panel.grid.minor = element_blank(),\n        panel.grid.major = element_blank())+\n  coord_equal()\n```\n\n::: {.cell-output-display}\n![](5.1-mapas_bivariados_files/figure-revealjs/unnamed-chunk-14-1.png){width=960}\n:::\n:::\n\n:::\n:::\n\n## Categorizar los datos\n\n-   vamos a usar las funciones `classInt()` y `findCols()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n x=classInt::classIntervals(stl_race_income$pctWhite,4,style = \"quantile\")\n y=classInt::classIntervals(stl_race_income$medInc,4,style = \"quantile\")\n \n x\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nstyle: quantile\n  one of 182,104 possible partitions of this variable into 4 classes\n       [0,3.140384) [3.140384,37.30553) [37.30553,69.86624) [69.86624,96.73367] \n                 27                  26                  26                  27 \n```\n:::\n:::\n\n\n## \n\n-   Agregar los valores calculados a la tabla *stl_race_income*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstl_race_income$x = classInt::findCols(x)\nstl_race_income$y = classInt::findCols(y)\n```\n:::\n\n\n## Crar un objeto para el `alpha` y otro para el `fill`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstl_race_income$alpha = as.character(stl_race_income$x + stl_race_income$y)\nstl_race_income$color = as.character(atan(stl_race_income$y/stl_race_income$x))\n```\n:::\n\n\n## Graficar el mapa\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap = ggplot()+\n  geom_sf(data = stl_race_income,aes(fill=color,alpha=alpha),shape=15, size=11,show.legend = FALSE)+\n  scale_fill_viridis_d()+\n  theme_void()\n```\n:::\n\n\n## \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap\n```\n\n::: {.cell-output-display}\n![](5.1-mapas_bivariados_files/figure-revealjs/unnamed-chunk-19-1.png){width=960}\n:::\n:::\n\n\n## Graficar la leyenda\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleg = ggplot(d, aes(x,y))+\n  geom_tile(aes(fill=atan(y/x),alpha=x+y))+\n  scale_fill_viridis_c()+\n  theme(legend.position=\"none\",\n        axis.text.y = element_blank(),\n        axis.text.x = element_blank(),\n        axis.ticks = element_blank(),\n        panel.grid.minor = element_blank(),\n        panel.grid.major = element_blank())+\n  coord_equal()\n```\n:::\n\n\n## \n\n\n::: {.cell}\n\n```{.r .cell-code}\nleg\n```\n\n::: {.cell-output-display}\n![](5.1-mapas_bivariados_files/figure-revealjs/unnamed-chunk-21-1.png){width=960}\n:::\n:::\n\n\n## Juntar los dos\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](5.1-mapas_bivariados_files/figure-revealjs/unnamed-chunk-22-1.png){width=960}\n:::\n:::\n\n\n## Se parecen?\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n::: {.cell-output-display}\n![](5.1-mapas_bivariados_files/figure-revealjs/unnamed-chunk-23-1.png){width=960}\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n![](https://chris-prener.github.io/biscale/reference/figures/biscale.002.jpeg)\n:::\n:::\n",
    "supporting": [
      "5.1-mapas_bivariados_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}