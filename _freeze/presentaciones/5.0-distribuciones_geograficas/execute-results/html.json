{
  "hash": "c0f395f216e7a04048f6249196c314da",
  "result": {
    "markdown": "---\ntitle: \"Distribuciones geográficas\"\nsubtitle: Daniel Valencia, Juliana Herrera & Fabricio Villalobos\nauthor: \"Instituto de Ecología, A.C.\"\nformat:\n  revealjs:\n    theme: curso_styles.scss\n    chalkboard: true\n    transition: fade\n    progress: true\n    preview-links: true\n    hide-inactive-cursor: true\n    highlight-style: printing\n    pause: true\n\neditor: visual\n---\n\n\n## Área de distribución geográfica\n\n\"...el espacio donde las condiciones ecológicas favorecen, real o potencialmente y en varios niveles, las interacciones no efímeras de los individuos de una especie\" Mota-Vargas & Rojas-Soto 2012\n\n## Puntos, polígonos y mapas de distribución\n\nLos registros (colectas georreferenciadas) de las especies son los datos primarios de biodiversidad, a partir de los cuales podemos estimar las áreas de distribución de estas y describir/evaluar los patrones de diversidad que emergen de su agregación (traslape; e.g., gradiente geográfico de riqueza)\n\n. . .\n\n## \n\n-   En este ejemplo/ejercicio veremos cómo obtener dichos registros directamente desde R\n\n. . .\n\n-   También, veremos cómo generar áreas de distribución (extensiones de presencia) a partir de estos registros, creando polígonos de diferentes tipos (mínimo, alpha y alpha dinámico)\n\n. . .\n\n-   Los datos de registros serán obtenidos de la plataforma en línea [Global Biodiversity Information Facility - GBIF](https://www.gbif.org/)\n\n. . .\n\n## Paquetes necesarios:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readr)\nlibrary(rgbif)\nlibrary(dplyr)\nlibrary(here)\nlibrary(ggplot2)\nlibrary(sf)\nlibrary(terra)\nlibrary(rnaturalearth)\nlibrary(alphahull)\nlibrary(rangeBuilder)\nlibrary(janitor)\nlibrary(ggthemes)\nlibrary(patchwork)\n```\n:::\n\n\n# Obteniendo registros de presencia de GBIF\n\n## \n\nPara comenzar podemos escoger una especie y aplicar la función `occ_data`\n\nEl objeto `sp_data` es una lista con datos sobre los resultados obtenidos en GBIF (incluyendo algunos metadatos)\n\nPara trabajar únicamente con la tabla de registros hay que seleccionar el objeto data dentro del mismo\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsp_data <- occ_data(scientificName = \"Musonycteris harrisoni\", limit = 500)[[2]]\n```\n:::\n\n\n. . .\n\n## \n\nChecar el nombre de las columnas (para después buscar únicamente las de posición geográfica: lat/long)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(sp_data)[1:30]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"key\"                    \"scientificName\"         \"decimalLatitude\"       \n [4] \"decimalLongitude\"       \"issues\"                 \"datasetKey\"            \n [7] \"publishingOrgKey\"       \"installationKey\"        \"hostingOrganizationKey\"\n[10] \"publishingCountry\"      \"protocol\"               \"lastCrawled\"           \n[13] \"lastParsed\"             \"crawlId\"                \"projectId\"             \n[16] \"basisOfRecord\"          \"individualCount\"        \"occurrenceStatus\"      \n[19] \"sex\"                    \"taxonKey\"               \"kingdomKey\"            \n[22] \"phylumKey\"              \"classKey\"               \"orderKey\"              \n[25] \"familyKey\"              \"genusKey\"               \"speciesKey\"            \n[28] \"acceptedTaxonKey\"       \"acceptedScientificName\" \"kingdom\"               \n```\n:::\n:::\n\n\n. . .\n\n## \n\n1.  Crear otro objeto a partir `sp_data` únicamente con long/lat\n\n. . .\n\n2.  Quedarse únicamente con los puntos/registros individuales (i.e., excluir duplicados)\n\n. . .\n\n3.  Transformarlo en un objeto espacial\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsp_p1<-sp_data%>%\n  select(decimalLongitude,decimalLatitude,species)%>%\n  mutate(lat=decimalLatitude,lon=decimalLongitude)%>%\n  distinct() %>%\n  na.omit() %>% \n  st_as_sf(coords = c('decimalLongitude','decimalLatitude'),crs=\"EPSG: 4326\")\n```\n:::\n\n\n::: {.alert .alert-success role=\"alert\"}\nNOTA: el nombre de la variable puede ser diferente (*e.g.*, \"LATITUDE\", \"Latidude\", \"lat\", etc. Siempre hay que checar antes)\n:::\n\n. . .\n\n## \n\nGraficar (poner en un mapa) los puntos de presencia de nuestra especie\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot()+ geom_sf(data=sp_p1, col=\"blue\",pch=19)\n```\n\n::: {.cell-output-display}\n![](5.0-distribuciones_geograficas_files/figure-revealjs/unnamed-chunk-5-1.png){width=960}\n:::\n:::\n\n\n## \n\nAgregar el mapa del mundo para saber qué onda!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrld <- ne_countries(scale = \"small\",returnclass = \"sf\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot()+\n  geom_sf(data=wrld)+geom_sf(data=sp_p1,col=\"blue\",pch=19,size=1)+coord_sf(expand = F) +\n  labs(x=\"Longitud decimal \",\n       y=\"Latitud decimal\",\n       title=expression(paste(\"Puntos reportados \", italic(\"Musonycteris harrisoni\"))))+\n  theme(plot.title = element_text(hjust = 0.5))\n```\n\n::: {.cell-output-display}\n![](5.0-distribuciones_geograficas_files/figure-revealjs/unnamed-chunk-7-1.png){width=960}\n:::\n:::\n\n\n## \n\nHay algo claramente equivocado, ¿cierto? Los puntos/registros necesitan ser \"curados\" (limpiados)\n\n. . .\n\nEliminar los puntos con mala georeferencia (en este caso, puntos obvios en el \"viejo mundo\")\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsp_p1<-sp_data%>%\n  select(decimalLongitude,decimalLatitude,species)%>%\n  mutate(lat=decimalLatitude,lon=decimalLongitude)%>%\n  distinct() %>% \n  na.omit() %>% \n  st_as_sf(coords = c('decimalLongitude','decimalLatitude'),crs=\"EPSG: 4326\")%>%\n  filter(lat> 0.5) %>% filter(lat< 22)\n```\n:::\n\n\n## \n\nAhora sí, mapeamos de nuevo pero sólamente en la región de interés (México)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmex_map <- filter(wrld,name==\"Mexico\")\n```\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot()+geom_sf(data=mex_map)+\n  geom_sf(data=sp_p1,col=\"blue\",pch=19,size=1)+coord_sf(expand = F)\n```\n\n::: {.cell-output-display}\n![](5.0-distribuciones_geograficas_files/figure-revealjs/unnamed-chunk-10-1.png){width=960}\n:::\n:::\n\n\n## \n\nY ¿Cómo eliminamos los registros que están en el mar?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsp_p1<-sp_data%>%\n  select(decimalLongitude,decimalLatitude,species)%>%\n  mutate(lat=decimalLatitude,lon=decimalLongitude)%>%\n  distinct() %>%\n  na.omit() %>% \n  st_as_sf(coords = c('decimalLongitude','decimalLatitude'),crs=\"EPSG: 4326\")%>%\n  filter(lat> 0.5) %>%\n  filter(lat< 22)%>%\n  filter(lon> -105.56611)\n```\n:::\n\n\n## \n\nVerifiquemos nuevamente los registros en el mapa\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot()+geom_sf(data=mex_map)+\n  geom_sf(data=sp_p1,col=\"blue\",pch=19,size=1)+coord_sf(expand = F)\n```\n\n::: {.cell-output-display}\n![](5.0-distribuciones_geograficas_files/figure-revealjs/unnamed-chunk-12-1.png){width=960}\n:::\n:::\n\n\n# Polígono mínimo convexo\n\n## \n\nUna vez tenemos los datos curados, podemos crear nuestro poligono mínimo convexo\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsp1_mcp <- st_convex_hull(st_union(sp_p1))\n```\n:::\n\n\n. . .\n\n¿Cómo se ve?\n\n## \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsp1_mcp2 <- st_as_sf(sp1_mcp)\n\nggplot()+\n  geom_sf(data=mex_map)+\n  geom_sf(data=sp1_mcp, fill=\"blue\")\n```\n\n::: {.cell-output-display}\n![](5.0-distribuciones_geograficas_files/figure-revealjs/unnamed-chunk-14-1.png){width=960}\n:::\n:::\n\n\n# Polígono alfa (alpha hull)\n\n## \n\nUsamos el paquete `alphahull`\n\nNOTA: Esta función solo acepta tablas como entrada\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsp_p2 <- as.data.frame(st_coordinates(sp_p1))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsp1_alphahull <- ahull(sp_p2, alpha = 6)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in eval(expr, envir, enclos): shull: duplicate points found\n```\n:::\n:::\n\n\n. . .\n\n*Error: shull: duplicate points found*\n\n. . .\n\nFalla porque encuentra puntos duplicados o, como en este caso, puntos en una línea recta (*i.e.*, mismo X y/o mismo Y).\n\n. . .\n\n## \n\n¿Cómo podemos identificar y solucionar este error?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsp_p3<-sp_p2 %>% select(X, Y)%>% \nmutate(X = ifelse(duplicated(sp_p2$X), X + rnorm(1, mean = 0, sd = 0.0001), X))%>% \nmutate(Y = ifelse(duplicated(sp_p2$Y), Y + rnorm(1, mean = 0, sd = 0.0001), Y))\n```\n:::\n\n\n. . .\n\n## \n\nAhora si, podemos crear el Alpha Hull con un valor de alpha escogido (por la razón que crean relevante)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsp1_alphahull <- ahull(sp_p3, alpha = 1) \n```\n:::\n\n\n. . .\n\n## \n\nPara observar el alpha hull, necesitamos que el objeto sea de tipo espacial del paquete `sf`. Para eso usaremos una función independiente, disponible en su carpeta de trabajo\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsource(file = here(\"data\",\"ah2sf.R\"))\nsp1_alphahull.poly <- ah2sf(sp1_alphahull)\n```\n:::\n\n\n## \n\n¿Cómo se ve?\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot()+\n  geom_sf(data=mex_map)+\n  geom_sf(data=sp1_alphahull.poly,fill=\"blue\")\n```\n\n::: {.cell-output-display}\n![](5.0-distribuciones_geograficas_files/figure-revealjs/unnamed-chunk-20-1.png){width=960}\n:::\n:::\n\n\n# Polígono alfa dinámico\n\n## \n\nUsamos el paquete `rangeBuilder`, el cual crea un polígono alpha hull con un valor de alpha \"óptimo\" basado en la distribución espacial de los puntos\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsp_range <- getDynamicAlphaHull(\n  sp_p3, #Tabla de puntos/registros de la especie\n  coordHeaders = c(\"decimalLongitude\", \"decimalLatitude\"),# x y y\n  fraction = 0.95,   # la fracción mínima de registros que debe incluir el polígono\n  partCount = 2,  # el máximo de polígonos disyuntos permitidos\n  initialAlpha = 1, # Alpha inicial\n  alphaIncrement = 0.5,\n  alphaCap = 1000,\n  clipToCoast = \"terrestrial\"  # solo la parte terrestre del polígono se mantendrá (se cortan las partes no-terrestres/acuáticas con base en un mapa descargado de naturalearth).\n)\n```\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nalpha <- sp_range[[2]]\nalpha\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"alpha1.5\"\n```\n:::\n:::\n\n\n## \n\nConvertir el polígono alpha a un objeto sf\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsp1_dynalpha <- st_make_valid(st_as_sf(sp_range[[1]]))\n```\n:::\n\n\n. . .\n\n¿Cómo podemos visualizarlo?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot()+ geom_sf(data=mex_map)+ \n  geom_sf(data=sp1_dynalpha, fill=\"blue\")\n```\n\n::: {.cell-output-display}\n![](5.0-distribuciones_geograficas_files/figure-revealjs/unnamed-chunk-24-1.png){width=960}\n:::\n:::\n\n\n## \n\n¿Y ....Cómo se ven todos los polígonos?\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot()+\n  geom_sf(data=mex_map)+ geom_sf(data=sp1_mcp,fill=\"red\",alpha=0.1) +\n  geom_sf(data=sp_range[[1]], fill=\"blue\",alpha=0.5)+ \n  geom_sf(data=sp1_alphahull.poly,fill=\"yellow\",alpha=0.5)\n```\n\n::: {.cell-output-display}\n![](5.0-distribuciones_geograficas_files/figure-revealjs/unnamed-chunk-25-1.png){width=960}\n:::\n:::\n\n\n## \n\nFinalmente, podemos salvar esos polígonos como `shapefiles`, para usarlos en otros software (*e.g.*, QGIS) y eventualmente juntar los de varias especies para otros análisis (ejercicio siguiente)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_write(sp1_mcp2, \"sp1_min_convex.shp\")\nst_write(sp1_alphahull.poly, \"sp1_alphahull.shp\")\nst_write(sp1_dynalpha, \"sp1_dyn_alphahull.shp\")\n```\n:::\n\n\n# Ajustes en los polígonos\n\n## \n\nPor ejemplo, para especies restringidas o dependientes de aguas continentales podemos implementar algunos ajustes luego de determinar su extensión de presencia\n\n. . .\n\nEn este ejercicio, vamos a utilizar un pez dulceacuícola (*Cyphocharax naegelii*), que se distribuye en la cuenca alta del río Paraná\n\n. . .\n\n-   Carguemos una base de datos con los registros de la especie ya limpios para la cuenca del alto Paraná\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatos <- read_csv(file = here(\"data/polygons\", \"registros.csv\")) %>%\n  select(\"longitude\", \"latitude\") %>%\n  mutate(longitude=ifelse(duplicated(longitude),longitude+rnorm(1,mean=0, sd=0.0001), longitude)) %>%\n  mutate(latitude=ifelse(duplicated(latitude),latitude+rnorm(1,mean=0, sd=0.0001),latitude))\n```\n:::\n\n\n. . .\n\n## \n\nY carguemos un shape de referencia para la cuenca del alto Paraná (https://www.hydrosheds.org/)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nM <- st_read( here(\"data/polygons\", \"Cyphocharax_naegelii.shp\")) %>% \n  st_transform(4326) %>% st_make_valid()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `Cyphocharax_naegelii' from data source \n  `/home/luisd/Dropbox/darcyDB/PDRF/R-biodiversidad-2024/data/polygons/Cyphocharax_naegelii.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 1 feature and 13 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: -58.64583 ymin: -27.81307 xmax: -43.58333 ymax: -15.45417\nGeodetic CRS:  WGS 84\n```\n:::\n:::\n\n\n## \n\nGrafiquemos los registros y la cuenca\n\n. . .\n\nNOTA: Debemos convertir los registros del objeto `datos` a un objeto de tipo `sf` para poder graficar en `ggplot`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatos_sf <- st_as_sf(datos, coords = c(\"longitude\", \"latitude\"), crs = 4326)\n```\n:::\n\n\n. . .\n\n## \n\nVeamos los registros distribuidos en la cuenca\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot()+\n  geom_sf(data=M, fill=\"white\", linewidth= 0.5, colour=\"black\")+\n  geom_sf(data=datos_sf, colour=\"blue\", size=1)+\n  coord_sf(crs=st_crs(4326), xlim=c(-58.2, -43.9), ylim=c(-28,-15), expand=TRUE)+\n  labs(x=\"Longitud decimal\", y=\"Latitud decimal\",\n       title=expression(paste(\"Registros reportados \", italic(\"Cyphocharax naegelli\"))))+\n  theme(plot.title=element_text(hjust=0.5))\n```\n\n::: {.cell-output-display}\n![](5.0-distribuciones_geograficas_files/figure-revealjs/unnamed-chunk-30-1.png){width=960}\n:::\n:::\n\n\n. . .\n\n## \n\nComo vamos a hacer dos tipos de ajustes, necesitamos algunos insumos complementarios:\n\n. . .\n\n1.  Otros shapes de cuencas, pero de menor orden (*i.e.*, cuencas más pequeñas); en este caso, subcuencas nivel 8 (HydroSHEDS)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Subcuencas nivel 8 (Hydrobasin)\ncuencas <- st_read(here(\"data/polygons\", \"Basins_8.shp\")) %>% \n  st_transform(4326) %>% st_make_valid()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `Basins_8' from data source \n  `/home/luisd/Dropbox/darcyDB/PDRF/R-biodiversidad-2024/data/polygons/Basins_8.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 1286 features and 31 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -58.64583 ymin: -27.81307 xmax: -43.58333 ymax: -15.45417\nGeodetic CRS:  WGS 84\n```\n:::\n:::\n\n\n. . .\n\n## \n\nGrafiquemos las subcuencas para tener una referencia visual\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot()+\n  geom_sf(data=cuencas, fill=\"white\", linewidth= 0.1, colour=\"black\")+\n  coord_sf(crs=st_crs(4326),xlim=c(-58.2, -43.9),ylim=c(-28,-15),expand=TRUE)\n```\n\n::: {.cell-output-display}\n![](5.0-distribuciones_geograficas_files/figure-revealjs/unnamed-chunk-32-1.png){width=960}\n:::\n:::\n\n\n. . .\n\n## \n\n2.  Ráster de referencia que represente los cuerpos de agua (*e.g.*, ríos, embalse)\n\n. . .\n\nDado que solo necesitamos el ráster como una referencia, asignaremos un valor único para todos los píxeles diferentes de NA\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmask <- rast(here(\"data/polygons\", \"rivers.tif\"))\nmask[!is.na(mask)]<-1\n```\n:::\n\n\n. . .\n\nNOTA: Para graficar el ráster, primero hay que convertirlo en un data.frame\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmask.2 <- as.data.frame(mask, xy = TRUE)\n```\n:::\n\n\n. . .\n\n## \n\n¿cómo se ve?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot()+\n  geom_sf(data=M, fill=\"white\", linewidth=0.5, colour=\"black\")+\n  geom_raster(data = mask.2, aes(x=x, y=y), fill=\"red\")+\n  coord_sf(crs=st_crs(4326),xlim=c(-58.2, -43.9),ylim=c(-28,-15),expand=TRUE)\n```\n\n::: {.cell-output-display}\n![](5.0-distribuciones_geograficas_files/figure-revealjs/unnamed-chunk-35-1.png){width=960}\n:::\n:::\n\n\n. . .\n\n## \n\nTeniendo los registros, capas de cuencas, y ráster de ríos, calculemos la extensión de presencia de la especie y luego ajustémoslo a las subcuencas, y a los cuerpos de agua\n\n. . .\n\n1.  Trazar el polígono (igual que en el primer ejercicio utilizando la función `ahull`)\n\n. . .\n\n2.  Interceptar el polígono trazado en el numeral anterior con la capa de subcuencas (nivel 8; objeto `cuencas`)\n\n. . .\n\n3.  Rasterizar el polígono interceptado y cortarlo a los cuerpos de agua utilizando la capa ráster de los ríos del objeto `mask`\n\n. . .\n\n## \n\nConstruir el polígono alfa\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnaegelli_poly <- ahull(datos, alpha = 1.5) %>% ah2sf()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot()+\n  geom_sf(data=M, fill=\"white\", linewidth= 0.5, colour=\"black\")+\n  geom_sf(data=naegelli_poly,fill=\"green\",linewidth=0.2,colour=\"black\",alpha=0.3)+\n  coord_sf(crs=st_crs(4326), xlim=c(-58.2, -43.9), ylim=c(-28,-15), expand=TRUE)\n```\n\n::: {.cell-output-display}\n![](5.0-distribuciones_geograficas_files/figure-revealjs/unnamed-chunk-37-1.png){width=960}\n:::\n:::\n\n\n. . .\n\n## \n\nInterceptar el polígono con las subcuencas\n\n\n::: {.cell}\n\n```{.r .cell-code}\nintersect_poly <- st_intersection(cuencas, naegelli_poly)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot()+\n  geom_sf(data=cuencas, fill=\"white\", linewidth= 0.1, colour=\"black\")+\n  geom_sf(data=intersect_poly$geometry,fill=\"green\",linewidth=0.2,colour=\"black\",alpha=0.3)+\n  coord_sf(crs=st_crs(4326), xlim=c(-58.2, -43.9), ylim=c(-28,-15), expand=TRUE)\n```\n\n::: {.cell-output-display}\n![](5.0-distribuciones_geograficas_files/figure-revealjs/unnamed-chunk-39-1.png){width=960}\n:::\n:::\n\n\n## \n\nSeleccionar del objeto `cuencas` los ID interceptados para unir las subcuencas seleccionadas\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrange_union <- cuencas[(intersect_poly),] %>% st_union()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot()+\n  geom_sf(data=M, fill=\"white\", linewidth= 0.5, colour=\"black\")+\n  geom_sf(data=range_union,fill=\"green\",linewidth=0.2,colour=\"black\",alpha=0.3)+\n  coord_sf(crs=st_crs(4326), xlim=c(-58.2, -43.9), ylim=c(-28,-15), expand=TRUE)\n```\n\n::: {.cell-output-display}\n![](5.0-distribuciones_geograficas_files/figure-revealjs/unnamed-chunk-41-1.png){width=960}\n:::\n:::\n\n\n. . .\n\n## \n\nPor último, utilizamos el polígono ajustado a las subcuencas (objeto `range_union`) y lo rasterizamos. Luego, lo cortamos a los ríos usando el ráster del objeto `mask`\n\n. . .\n\nNOTA: Dado que el objeto final es una capa ráster, necesitamos transformarla en un data.frame para poder graficarla en `ggplot`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwater_restric<-rasterize(st_as_sf(vect(range_union)),mask,getCover=TRUE)%>% \n  crop(mask, mask = TRUE, snap = \"near\") %>%\n  as.data.frame(xy = TRUE)\n```\n:::\n\n\n. . .\n\n## \n\nVeamos la extensión de presencia ajustada a los ríos\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot()+\n  geom_sf(data=M, fill=\"white\", linewidth=0.5, colour=\"black\")+\n  geom_raster(data = water_restric, aes(x=x, y=y), fill=\"red\")+\n  coord_sf(crs=st_crs(4326),xlim=c(-58.2, -43.9),ylim=c(-28,-15),expand=TRUE)\n```\n\n::: {.cell-output-display}\n![](5.0-distribuciones_geograficas_files/figure-revealjs/unnamed-chunk-43-1.png){width=960}\n:::\n:::\n\n\n. . .\n\n## \n\nGrafiquemos ambos resultados para tener una aproximación visual\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunrestrict_range <-\n  ggplot()+\n  geom_sf(data=M, fill=\"white\", linewidth= 0.5, colour=\"black\")+\n  geom_sf(data=range_union,fill=\"green\",linewidth=0.2,colour=\"black\",alpha=0.3)+\n  coord_sf(crs=st_crs(4326), xlim=c(-58.2, -43.9), ylim=c(-28,-15), expand=TRUE)+\n  labs(x=\"Longitud decimal\", y=\"Latitud decimal\",\n       title=expression(paste(\"Sin restricciones a cuerpos de agua\")))+\n  theme(plot.title=element_text(hjust=0.5))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrestrict_range <-\nggplot()+\n  geom_sf(data=M, fill=\"white\", linewidth=0.5, colour=\"black\")+\n  geom_raster(data = water_restric, aes(x=x, y=y), fill=\"red\") +\n  coord_sf(crs=st_crs(4326), xlim=c(-58.2, -43.9), ylim=c(-28,-15), expand=TRUE)+\n  labs(x=\"Longitud decimal\", y=\"\",\n       title=expression(paste(\"Restringido a cuerpos de agua\")))+\n  theme(plot.title=element_text(hjust=0.5))\n```\n:::\n\n\n. . .\n\n## \n\n\n::: {.cell}\n\n```{.r .cell-code}\n(unrestrict_range | restrict_range) +\n  plot_layout(widths = c(1, 1))\n```\n\n::: {.cell-output-display}\n![](5.0-distribuciones_geograficas_files/figure-revealjs/unnamed-chunk-46-1.png){width=960}\n:::\n:::\n\n\n. . .\n",
    "supporting": [
      "5.0-distribuciones_geograficas_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}