---
title: "Manipulaci√≥n y limpieza de datos"
author: Luis D. Verde Arregoitia
format:
  revealjs:
    theme: curso_styles.scss
    chalkboard: true
    transition: fade
    progress: true
    preview-links: true
    hide-inactive-cursor: true
    highlight-style: printing
    pause: true
editor: source
knitr:
  opts_chunk:
    dev: "ragg_png"
    retina: 3
    dpi: 200
execute:
  freeze: auto
  cache: true
  echo: true
  fig-width: 5
  fig-height: 6
---

```{r setup}
#| echo: false
library(janitor)
library(tidyr)
library(stringr)
library(dplyr)
library(datos)
library(gt)
```

### Temas del bloque:

-   'pipes' y el `tidyverse`¬†
-   Estructuras y organizaci√≥n de datos\
-   M√©todos para reestructurar tablas y archivos\
-   Principios de datos ordenados (**tidy data**) y herramientas del '`tidyverse`' para ordenar datos\
-   Expresiones regulares para trabajar con cadenas de texto\
-   Herramientas para manejar datos faltantes\
-   Formas de identificar informaci√≥n repetida

## Pipes (\\paips\\)

Si queremos hacer varias operaciones en secuencia:

::: incremental
-   C√≥digo anidado (los resultados se eval√∫an de adentro hacia afuera)

-   Objetos intermedios (creamos objetos con resultados intermedios y para la siguiente funci√≥n en la secuencia)

-   Pipes (estructuramos operaciones seriadas de izquierda a derecha)
:::

## C√≥digo anidado

</br>

::: big-code
```{r}
#| eval: true
#| echo: true

notas <- c(7,8,8,10,6,9,5,9,8)

round(mean(notas), digits = 2)
```
:::

## Objetos intermedios

</br>

::: med-code
```{r}
#| eval: true
#| echo: true
notas_promedio <- mean(notas)

notas_promedio_rd <- 
  round(notas_promedio,
           digits = 2)

notas_promedio_rd
```
:::

## Pipes

::: fragment
::: columns
::: {.column width="30%"}
Mano izquierda\
(LHS)
:::

::: {.column width="40%"}
operador 'pipe'

`%>%`\
de üì¶ `magrittr`

`|>` en R v \>= 4.1.0
:::

::: {.column width="30%"}
Mano derecha\
(RHS)
:::
:::
:::

::: fragment
Toma un objeto a la izquierda del operador y lo inserta como argumento en la funci√≥n a su derecha

\* Por defecto lo que est√© a la izquierda del 'pipe' se inserta como el primer argumento de la funci√≥n
:::

## Pipes

-   Reducen la necesidad de guardar resultados intermedios o de anidar c√≥digo

-   C√≥digo m√°s f√°cil de leer

-   M√°s f√°cil quitar o agregar pasos a la secuencia

> Insertamos con `ctrl + shift + M`

::: rightref
::: refbox
Adolfo √Ålvarez (2021)\
[The (updated) history of the pipe operator in R](http://adolfoalvarez.cl/blog/2021-09-16-plumbers-chains-and-famous-painters-the-history-of-the-pipe-operator-in-r/)
:::
:::

------------------------------------------------------------------------

</br>

::: big-code
```{r}
#| echo: true
library(magrittr)
notas %>% 
  mean() %>% 
  round(digits=2)
```
:::

::: big-code
```{r}
#| echo: true
notas %>% 
  mean %>% 
  round(digits=2)
```
:::

##

::: big-code
```{r}
#| echo: true
notas |> 
  mean() |> 
  round(digits=2)
```
:::

## 

</br>

::: {style="text-align: center"}
`LHS |> RHS(argument = 12)`

*se convierte en*

`RHS(LHS, argument = 12)`
:::

## tidyverse

::: columns
::: {.column width="20%"}
![](imgs/tidyverse_celestial.png)
:::

::: {.column width="80%"}
> ... una colecci√≥n de paquetes de R dise√±ados para ciencia de datos. Todos los paquetes comparten una filosof√≠a de dise√±o, gram√°tica, y estructuras de datos. Su objetivo principal es de 'facilitar una conversaci√≥n sobre datos entre un humano y su computador'
:::
:::

::: rightref
::: refbox
Wickham et al. (2019)\
[Welcome to the tidyverse](https://www.theoj.org/joss-papers/joss.01686/10.21105.joss.01686.pdf)\
https://www.tidyverse.org/
:::
:::

## tidyverse

-   Para tareas comunes con datos: importar archivos, limpiar datos, transformar, visualizar, o programar nuevas funciones.

-   Dise√±ado para facilitar su aprendizaje y que los usuarios vayan aprendiendo m√°s funciones conforme interact√∫en con m√°s elementos de este 'ecosistema'.

::: rightref
::: refbox
√áetinkaya-Rundel et al. ([2021](https://arxiv.org/abs/2108.03510))\
An educator's perspective of the tidyverse
:::
:::

##

![[Teaching the tidyverse in 2023](https://www.tidyverse.org/blog/2023/08/teach-tidyverse-23/)](https://www.tidyverse.org/blog/2023/08/teach-tidyverse-23/images/data-science.png)

## tibbles (/tibls/)

Modernizando el `data.frame`

Implementado para todo el `tidyverse` a trav√©s de üì¶ `tibble`

```{r}
tibble(
  x = c("a", "b", "c"),
  y = c(1, 2, 3)
)
```

. . .

Objeto rectangular com√∫n para todos los paquetes del `tidyverse`

## Funciones de `tidyverse`

::: incremental
-   reciben un `data.frame` ‚û°Ô∏è regresan un `data.frame`

-   reciben un `tibble` ‚û°Ô∏è regresan un `tibble`

-   generan un objeto nuevo ‚û°Ô∏è crean un `tibble`
:::

## Creando tibbles

-   Salida predeterminada de funciones

-   Convirtiendo otros objetos con `as_tibble()`

-   Construyendo a partir de vectores con `tibble()`

## tibbles

Para menos ambig√ºedad:

. . .

::: incremental
-   No asignan nombres a las filas

-   No modifican los nombres de las columnas

-   No convierten caracteres en factores

-   Exigen nombres completos para seleccionar subconjuntos de variables con `$`
:::

## Impresi√≥n de tibbles

Para no saturar la consola, los m√©todos de impresi√≥n para *tibbles* muestran:

::: incremental
-   Las primeras 10 filas

-   Cu√°ntas filas y columnas no se imprimieron

-   Solo las columnas que entran en el ancho de nuestra pantalla

-   El tipo de variable de todas las columnas
:::

# Organizando informaci√≥n

## ¬øQu√© problemas vemos con esta presentaci√≥n de datos? {background-color="#a4c5ff"}

![](imgs/datosWord.png)

## M√°s utilizable

```{r}
#| echo: false
tibble::tribble(
         ~Nombre, ~Periodo,      ~TipoViaje, ~PropositoViaje, ~Costo, ~Pais,
     "Miguel J.",    2022L,      "Nacional",  "Salida campo",  1000L,  "MX",
     "Miguel J.",    2022L,      "Nacional",  "Salida campo",  1000L,  "MX",
     "Miguel J.",    2022L,      "Nacional",      "Congreso",   500L,  "MX",
     "Miguel J.",    2022L,      "Nacional",        "Taller",   500L,  "MX",
     "Miguel J.",    2022L, "Internacional",      "Congreso",  2000L, "EUA",
  "Alejandra M.",    2022L,              NA,              NA,     NA,    NA,
       "Raul S.",    2022L,      "Nacional",  "Salida campo",  1000L,  "MX"
  ) %>% gt() %>%
    tab_style(
    cell_text(size = "29px"),
    locations = list(
      cells_body(),
      cells_column_labels(everything()),
      cells_title()
    )
  )


```

## Datos bien organizados

-   M√°s f√°cil de importar y manipular

-   Menos potencial de errores no replicables (alteraciones, omisiones, duplicaciones)

Siguiendo buenos principios de organizaci√≥n producimos mejores datos y podremos identificar y resolver problemas en datos existentes

## Recomendaciones

-   Unidades, nombres, esquemas, fechas etc. **consistentes**

-   Nombres utilizables

-   Estructuras rectangulares

::: rightref
::: refbox
::: columns
::: {.column width="33%"}
Openscapes (2020)\
[Tidy data illustrated](https://www.openscapes.org/blog/2020/10/12/tidy-data/)
:::

::: {.column width="33%"}
Broman and Woo (2018)\
[Organizing data in spreadsheets](https://doi.org/10.1080/00031305.2017.1375989)
:::

::: {.column width="33%"}
Verde Arregoita et al. (2018)\
[Good practices for sharing analysis-ready data...](https://doi.org/10.4404/hystrix-00133-2018)
:::
:::
:::
:::

## Consistencia

Tablas relacionadas con datos sobre seguimiento GPS de aves

::: columns
::: {.column width="50%"}
```{r}
#| echo: false

tibble::tribble(
  ~id,       ~ave,     ~edad,    ~estado,
  23L,  "gorri√≥n", "juvenil",      "VER",
  11L,     "buho",  "adulto", "Veracruz",
   7L,     "buho",       "j",   "Puebla",
  40L, "codorniz",  "ADULTO",       "PU",
  34L,  "gorri√≥n",       "1",      "VER",
  30L,   "paloma",       "A",        "V"
  ) %>% gt() %>%  
  tab_style(
    cell_text(size = "26px"),
    locations = list(
      cells_body(),
      cells_column_labels(everything()),
      cells_title()
    )
  )

```
:::

::: {.column width="50%"}
```{r}
#| echo: false

tibble::tribble(
  ~ID_ave, ~num_rasteador, ~sexo,
      23L,         "b452",   "M",
      11L,         "b256",   "M",
       7L,         "a122",   "F",
      40L,         "b889",   "M",
      34L,         "d136",   "F"
  ) %>% gt() %>% 
  tab_style(
    cell_text(size = "26px"),
    locations = list(
      cells_body(),
      cells_column_labels(everything()),
      cells_title()
    ))

```
:::
:::

::: {style="text-align: center"}
¬øCu√°ntas inconsistencias ven aqu√≠?
:::

## Datos rectangulares

::: columns
::: {.column width="30%"}
![](imgs/rectangle1.png)
:::

::: {.column width="70%"}
Objetos con filas y columnas, en los cuales:

-   Cada fila tiene el mismo n√∫mero de columnas

-   Cada columna tiene el mismo n√∫mero de filas

-   Vectores o factores de la misma longitud entonces todas las columnas tienen la misma 'altura'
:::
:::

## datos rectangulares \~¬†rangos de celdas en una hoja de c√°lculo

::: columns
::: {.column width="50%"}
![](imgs/cashflow.png)
:::

::: {.column width="50%"}
![](imgs/rangespresp.png)
:::
:::

::: rightref
::: refbox
Davis Vaughan (2018)\
[Tidying Excel cash flow spreadsheets](https://blog.davisvaughan.com/2018/02/16/tidying-excel-cash-flow-spreadsheets-in-r/)
:::
:::

## 

<blockquote class="twitter-tweet tw-align-center" data-conversation="none">

<p lang="en" dir="ltr">

but sometimes such data is "rectangular" in the same sense that this cat is "bowl-shaped" üòÇ <a href="https://t.co/ZmxvgcV57d">pic.twitter.com/ZmxvgcV57d</a>

</p>

--- Jenny Bryan (@JennyBryan) <a href="https://twitter.com/JennyBryan/status/1126582138344595456?ref_src=twsrc%5Etfw">May 9, 2019</a>

</blockquote>

```{=html}
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
```
## 

::: columns
::: {.column width="50%"}
```{r}
#| echo: false
tibble::tribble(
    ~animal, ~ind_observados, ~habitat,
  "caracol",             12L,    "mar",
  "gaviota",             14L,  "costa",
   "nutria",             11L,    "r√≠o"
  ) %>% gt() %>% 
    tab_style(
    cell_text(size = "33px"),
    locations = list(
      cells_body(),
      cells_column_labels(everything()),
      cells_title()
    ))

```
:::

::: {.column width="50%"}
```{r}
#| echo: false
tibble::tribble(
  ~caracol, ~gaviota, ~nutria,
      "12",     "14",    "11",
     "mar",  "costa",   "r√≠o"
  ) %>% gt() %>% 
    tab_style(
    cell_text(size = "33px"),
    locations = list(
      cells_body(),
      cells_column_labels(everything()),
      cells_title()
    ))

```
:::
:::

# Estructurando datos

## ¬øDatos listos para uso?

-   Agrupar, transformar, ordenar, visualizar, modelar, compartir, etc.

![](imgs/data-science-communicate.svg){fig-align="center"}

## ¬øNo se puede?

-   Ordenar para un manejo m√°s f√°cil y eficiente

## Datos ordenados (*tidy data*)

Una reinterpretaci√≥n accesible de distintos principios y definiciones de estad√≠stica y ciencias de la computaci√≥n

</br>

::: rightref
::: refbox
Wickham (2014)\
[Tidy Data](https://www.jstatsoft.org/article/view/v059i10/) - Journal of Statistical Software
:::
:::

## 'Tidy data'

-   Datos acomodados en una matriz 2D con filas y columnas

-   Las filas corresponden a observaciones

-   Las columnas corresponden a variables

-   Un solo valor por celda

## 

![](imgs/datosords.png){width="90%"}

## 

![](imgs/datosordslab.png)

## ¬øPara qu√©?

M√°s f√°cil de reacomodar y manejar

![](imgs/pivotingintro.gif)

## ¬øPara qu√©?

### Trabajando con filas

Los valores de cada observaci√≥n quedan juntos

![](imgs/descuentos.png)

## 

::: columns
::: {.column width="40%"}
![](imgs/mapeovarstidy.png)
:::

::: {.column width="60%"}
</br> Las variables entran directamente como especificaciones para modelos y/o par√°metros gr√°ficos
:::
:::

## Cu√°ndo no

-   Los datos ordenados son m√°s repetitivos y pueden ocupar m√°s espacio que otras representaciones m√°s compactas

</br>

-   No es un formato ideal para la captura de datos, o para tablas que forman parte de alg√∫n texto que ser√° impreso

# Consejos r√°pidos de organizaci√≥n de datos

## Variables por separado para definir grupos

Usar 'variables indicadoras' en lugar de colapsar informaci√≥n entre dos o m√°s variables.

::: columns
::: {.column width="37%"}
![](imgs/gruposvars.png)
:::

::: {.column width="63%"}
```{r}
#| echo: false

tibble::tribble(
     ~Equipo,      ~Liga, ~Victorias, ~Clasificado,
      "Osos",  "Primera",         8L,         "SI",
   "Venados", "Reservas",         2L,         "NO",
  "Dragones",  "Primera",        12L,         "SI",
    "Leones",  "Primera",         4L,         "NO",
  "F√©nix FC", "Reservas",         7L,         "SI"
  ) %>% gt()%>% 
    tab_style(
    cell_text(size = "32px"),
    locations = list(
      cells_body(),
      cells_column_labels(everything()),
      cells_title()
    ))

```
:::
:::

## Valores faltantes

No se registraron, no aplican, se perdieron, etc.

. . .

</br> [Los datos faltantes siguen siendo datos]{style="font-size: 1.5em; text-align: center"} </br>

En R usamos [NA]{style="color:red; font-family: Liberation Mono; font-weight: bold"}, una constante especial que indica valores faltantes

------------------------------------------------------------------------

-   Tratar los valores [NA]{style="color:red; font-family: Liberation Mono; font-weight: bold"} consistentemente

-   Evitar ambig√ºedad

> ¬øFalta un valor, se dej√≥ una celda en blanco intencionalmente, o la medici√≥n no aplica?

-   No usar celdas vac√≠as como relleno para alinear datos o con fines est√©ticos-estructurales

-   Evitar valores [`NA`]{style="color:red"} en nombres de variables

## 

::: {.columns style="display: flex !important; height: 90%;"}
::: {.column width="50%" style="display: flex; justify-content: center; align-items: center;"}
![](imgs/ambiguo.png)
:::

::: {.column width="50%" style="display: flex; justify-content: center; align-items: center"}
![](imgs/mejor.png)
:::
:::

## Encabezados utilizables (nombres de las columnas)

Nombres poco informativos e inconsistentes

```{r}
#| echo: false
#| eval: true

tibble::tribble(
           ~X,     ~x1,            ~X2, ~calif_min, ~CALIFICACION.PROMEDIO,
       "UANL", "Norte", "Arquitectura",         6L,                    8.9,
         "UT", "Norte",       "Dise√±o",         7L,                   7.78,
      "UABJO",   "Sur",       "Dise√±o",         6L,                    8.5
      ) %>%
  gt() %>%
  tab_style(
    cell_text(size = "25px"),
    locations = list(
      cells_body(),
      cells_column_labels(everything()),
      cells_title()
    )
  )
```

-   M√°s dif√≠cil de recordar para hacer referencia a diferentes variables

-   No se ordenan bien (alfa-num√©ricamente)

## 

```{r}
#| echo: false
#| eval: true


tibble::tribble(
  ~universidad, ~region,          ~area, ~calificacion_minima, ~calificacion_promedio,
        "UANL", "Norte", "Arquitectura",                   6L,                    8.9,
          "UT", "Norte",       "Dise√±o",                   7L,                   7.78,
       "UABJO",   "Sur",       "Dise√±o",                   6L,                    8.5
  ) %>%
  gt() %>%
  tab_style(
    cell_text(size = "25px"),
    locations = list(
      cells_body(),
      cells_column_labels(everything()),
      cells_title()
    )
  )
```

## Nombres de columna partidos

```{r}
#| echo: false
#| eval: true
  
tibble::tribble(
  ~universidad, ~region,          ~area, ~calificacion_, ~calificacion,
            NA,      NA,             NA,      "minima",    "promedio",
        "UANL", "Norte", "Arquitectura",           "6",         "8.9",
          "UT", "Norte",       "Dise√±o",           "7",        "7.78",
       "UABJO",   "Sur",       "Dise√±o",           "6",         "8.5"
  ) %>% gt() %>% 
  tab_style(
    cell_text(size = "25px"),
    locations = list(
      cells_body(),
      cells_column_labels(everything()),
      cells_title()
    )
  )
```

-   Los nombres de las columnas aparecen en \>1 fila

-   Mezcla de fragmentos de nombre con datos

-   Se pierden los separadores entre palabras

-   Se introducen `NA` ::: :::

# Compartiendo datos

## Datos compartidos adecuadamente

F√°ciles de interpretar (por humanos y por m√°quinas) y listos para analizar

‚Üò Reduce la dependencia a software complejo o caro y disminuye la necesidad de saber programar para limpiar datos complejos

‚Üò Reducir la interpretaci√≥n que habr√° que hacer para poder usar los datos

## Formatos

::: columns
::: {.column width="50%"}
-   El PDF no es un formato para datos
:::

::: {.column width="50%"}
![](imgs/pdfprision.jpg)
:::
:::

-   Mientras m√°s simple mejor (ej: csv, txt)

-   Compartir datos, guardar c√°lculos y resultados por separado

# Herramientas para manipular datos rectangulares

## üî® para preparar, transformar, y estructurar datos


üì¶ **`dplyr`** y üì¶ **`tidyr`**

Flexibles, pero desarrollados en torno a una filosof√≠a com√∫n

-   Trabas para no usar las funciones incorrectamente\
-   Menos c√≥digo para lograr un resultado
-   Gram√°tica y estructuras de datos compartidas
-   Tareas divididas entre funciones y paquetes
-   Uso de 'pipes'

## Funciones √∫tiles de üì¶ `dplyr`

-   Funciones separadas para las operaciones m√°s comunes

-   Cada funci√≥n solo hace una cosa pero la hace bien

</br>

-   Funciones intuitivas para:

    -   Crear subconjuntos de filas y columnas

    -   Crear o modificar columnas

## 

```{r}
#| echo: false 
#| eval: true

paises_m <- 
tibble::tribble(
        ~pais, ~especies, ~amenazadas,   ~region,
  "Indonesia",      670L,        191L,    "Asia",
     "Brasil",      648L,         80L, "America",
      "China",      551L,         73L,    "Asia",
     "Mexico",      523L,         96L, "America",
       "Peru",      467L,         53L, "America",
      "Congo",      430L,         15L,  "Africa",
      "India",      412L,         93L,    "Asia",
      "Kenya",      376L,         30L,  "Africa",
  "Argentina",      374L,         38L, "America",
    "Ecuador",      372L,         47L, "America",
  "Venezuela",      363L,         35L, "America",
   "Tanzania",      359L,         41L,  "Africa"
  )



```

::: panel-tabset
### Pa√≠ses megadiversos

```{r}
#| echo: false 
#| eval: true
paises_m %>% gt() %>% 
  tab_style(
    cell_text(size = '21px'),
    locations = list(cells_body(),
                     cells_column_labels(everything()),
                     cells_title()))
```

### Datos

```{r}
#| echo: true
#| eval: false
paises_m <- 
tibble::tribble(
        ~pais, ~especies, ~amenazadas,   ~region,
  "Indonesia",      670L,        191L,    "Asia",
     "Brasil",      648L,         80L, "America",
      "China",      551L,         73L,    "Asia",
     "Mexico",      523L,         96L, "America",
       "Peru",      467L,         53L, "America",
      "Congo",      430L,         15L,  "Africa",
      "India",      412L,         93L,    "Asia",
      "Kenya",      376L,         30L,  "Africa",
  "Argentina",      374L,         38L, "America",
    "Ecuador",      372L,         47L, "America",
  "Venezuela",      363L,         35L, "America",
   "Tanzania",      359L,         41L,  "Africa"
  )

```
:::

## `select()`

::: columns
::: {.column width="30%"}
#### Seleccionar columnas

-   por nombre\
-   por posici√≥n\
-   por tipo\
:::

::: {.column width="70%"}
::: med-code
```{r}
paises_m %>% 
  select(pais,
         amenazadas) %>% 
  head(4)
```
:::
:::
:::

## `mutate()`

::: columns
::: {.column width="35%"}
#### Crea o modifica columnas

-   Crear nuevas\
-   'sobre-escribir' existentes\
:::

::: {.column width="65%"}
```{r}

paises_m %>%
  select(pais, amenazadas) %>% 
  mutate(amenazadas_log = log(amenazadas)) %>% 
  head(5)
```
:::
:::

Podemos controlar en d√≥nde aparece la nueva columna con los argumentos `.before` y `.after`

## `filter()`

#### Seleccionar filas

Retiene solamente las filas que cumplen una condici√≥n

::: med-code
```{r}
paises_m %>% 
  select(pais, especies, amenazadas) %>% 
  filter(amenazadas > 75)
```
:::

## `rename()`

#### Cambiar nombres de columnas

Nombre nuevo primero *luego* variable objetivo

::: med-code
```{r}
paises_m %>% 
  rename(country = pais,species = especies, threatened = amenazadas) %>% 
  head()

```
:::

## Ejercicio - Datos desde paquetes (1) {background-color="#a4c5ff"}

</br>

[`data()`]{style="color:##7b7bb4; font-weight=bold"} carga o genera una lista de juegos de datos disponibles con los paquetes que tengamos instalados </br>

[`data()`]{style="color:##7b7bb4; font-weight=bold"} sin ning√∫n argumento muestra todos los datos disponibles

## Ejercicio - Datos desde paquetes (2) {background-color="#a4c5ff"}

Podemos especificar de cu√°l paquete enlistar datos

[`data(package="ggplot2")`]{style="font-size: 1.5em; text-align: center"}

[`data(package="datasets")`]{style="font-size: 1.5em; text-align: center"}

[`data(package="tidyr")`]{style="font-size: 1.5em; text-align: center"}

## Ejercicio - Datos desde paquetes (3) {background-color="#a4c5ff"}

<br/> `data()` carga datos desde un paquete, como argumento usamos el nombre del juego de datos que necesitamos (con o sin comillas)

> Debe estar cargado el paquete que contiene los datos

```{r}
#| eval: false
#| echo: true

library(ggplot2)
data(economics)

library(openintro)
data("nba_players_19")
```

## Ejercicio - manipulaci√≥n de datos {background-color="#a4c5ff"}

-   Cargar el objeto `pinguinos`, se instala con el paquete `datos`

> Por ahora los datos de este paquete no s cargan con `data()`

-   Crear un subconjunto de datos que solo incluya `especie`, `isla`, y `largo_aleta_mm`

-   ¬øCu√°ntos individuos tienen aletas \> a 195 mm?

-   Crea una nueva columna con el largo de aleta en pulgadas

# Trabajando con \> 1 columna con `across()`

## Operaciones con varias columnas en simult√°neo

[`across()`]{style="font-size: 1.5em; text-align: center"}

Para aplicar `filter` o `mutate` a varias columnas

-   Columnas especificadas por posici√≥n (no es buena opci√≥n), nombre, o tipo

-   Selecciones compuestas\
    (ej: *variables de tipo factor* que contienen 'temp' en su nombre)

## argumentos de `across()`:

[.cols]{style="color:green font-size: 1.3em"} Columnas para transformar

[.fns]{style="color:pink font-size: 1.3em"} Funci√≥n a aplicarse a cada una

> `across` espera una funci√≥n entonces el nombre y sus argumentos se pueden pasar por separado

------------------------------------------------------------------------

<br/>

```{r}
#| echo: true
paises_m %>% 
  mutate(across(c(especies, amenazadas), `*`, 2)) %>% 
  head(3)
```

-   `.cols` es un vector con los nombres de las dos columnas que nos interesan

-   `*` es la funci√≥n para aplicar, `2` es su argumento

## Funciones adicionales para referirnos a columnas

Existen funciones auxiliares para especificar conjuntos de variables, se usan junto con o en lugar de `across()`

</br>

::: rightref
::: refbox
\[[dplyr selection features and helpers](https://dplyr.tidyverse.org/reference/dplyr_tidy_select.html)\]
:::
:::

## `everything()`

Todas las variables

::: med-code
```{r}
#| eval: true
#| echo: true
paises_m %>% 
  mutate(across(everything(), as.character)) %>% head(3)
```
:::

## `!`

Devuelve el complemento de un conjunto de variables

::: med-code
```{r}
#| eval: true
#| echo: true
paises_m %>% 
  select(!c(region,amenazadas)) %>% head()
```
:::

## `where()`

Selecciona las variables para las cuales alguna comparaci√≥n regrese `TRUE`

> ej: transformar todas las variables de tipo num√©rico, identificadas con `is.numeric()`

```{r}
paises_m %>% 
  mutate(across(where(is.numeric), log2)) %>% slice(1:3)
```

## `matches()`

Encuentra nombres de variables con expresiones regulares

> ej: palabra de 4 letras, 'p' al principio y 's' al final 

```{r}
paises_m %>% 
  mutate(across(matches("p..s"), toupper)) %>% head
```

## `:`

Selecciona variables contiguas

::: med-code
```{r}
paises_m %>% 
  select(pais:amenazadas) %>% head()
```
:::

## `-`

Excluir variables

(devuelve todos los elementos excepto el que sigue el operador de resta)

::: med-code
```{r}
paises_m %>% 
  select(-region) %>% head()
```
:::

## `across` sin funciones auxiliares

Ra√≠z cuadrada (`sqrt()`) de `especies` y `amenazadas`

```{r }
#| eval: true
#| echo: true
paises_m %>%  
  mutate(across(c(especies, amenazadas), sqrt)) %>% 
  head()
```

## Ra√≠z cuadrada (`sqrt()`) de todas las variables num√©ricas

```{r}
#| eval: true
#| echo: true
paises_m %>% 
  mutate(across(where(is.numeric), sqrt)) %>% 
  head()
```

## Funciones auxiliares para descartar variables

Dejar solo variables num√©ricas

```{r}
#| eval: true
#| echo: true
 
paises_m %>% 
  select(where(is.numeric)) %>% 
  head()
```

# Pivotar/pivotear datos

## 

::: columns
::: {.column width="50%"}
### Datos anchos

- Lectura y captura m√°s f√°cil\
- √ötil para edici√≥n interactiva en hojas de c√°lculo\
:::

::: {.column width="50%"}
### Datos largos

- Tiende a seguir principios de Datos Ordenados\
- Listos para analizar\
- Se vinculan directamente con par√°metros est√©ticos en un gr√°fico
:::
:::

![](imgs/widelong.png){width="80%" fig-align="left"}

## Reestructurando datos con üì¶ `tidyr`

<br/> ancho a largo: `pivot_longer()`

::: med-code
```{r}
#| eval: false
#| echo: true
 
pivot_longer(data, cols, names_to, values_to)
```
:::

<br/> largo a ancho: `pivot_wider()`

::: med-code
```{r}
#| echo: true
#| eval: false
 
pivot_longer(data, cols, names_from, values_from)
```
:::

## 

```{r}
#| eval: true
#| echo: false

colonias <- 
tibble::tribble(
    ~Asentamiento,                 ~Tipo,    ~CP, ~Abarrotes, ~Supermercado, ~Minisuper,
  "Arroyo Blanco",             "Colonia", 91025L,         7L,            2L,         1L,
         "Atenas",     "Fraccionamiento", 91184L,         1L,            0L,         2L,
       "Colibris",             "Colonia", 91067L,         8L,            3L,         2L,
      "Del Valle", "Unidad Habitacional", 91097L,         2L,            1L,         1L,
     "El Cafetal",     "Fraccionamiento", 91150L,         2L,            0L,         0L
  )



```

::: panel-tabset
## colonias

```{r}
#| eval: true
#| echo: false

colonias %>% gt() %>% 
    tab_style(
    cell_text(size = '24px'),
    locations = list(cells_body(),
                     cells_column_labels(everything()),
                     cells_title())) %>% 
  tab_options(table.background.color="#f4f4f9")
```

## Datos

```{r panel-chunk-cols}
#| eval: false
#| echo: true

colonias <- 
tibble::tribble(
    ~Asentamiento,                 ~Tipo,    ~CP, ~Abarrotes, ~Supermercado, ~Minisuper,
  "Arroyo Blanco",             "Colonia", 91025L,         7L,            2L,         1L,
         "Atenas",     "Fraccionamiento", 91184L,         1L,            0L,         2L,
       "Colibris",             "Colonia", 91067L,         8L,            3L,         2L,
      "Del Valle", "Unidad Habitacional", 91097L,         2L,            1L,         1L,
     "El Cafetal",     "Fraccionamiento", 91150L,         2L,            0L,         0L
  )

```
:::

¬øQu√© variables tenemos?

## Ancho a largo

```{r}
#| eval: true
#| echo: true

colonias_largo <- colonias %>%
  pivot_longer(
    cols = c(Abarrotes,Supermercado,Minisuper),
    names_to = "tipo_negocio",
    values_to = "n_negocios")
```

```{r}
#| eval: true
#| echo: false

colonias_largo <- colonias %>%
  pivot_longer(
    cols = c(Abarrotes,Supermercado,Minisuper),
    names_to = "tipo_negocio",
    values_to = "n_negocios")
```

**`cols`** Las columnas cuyos nombres son datos

**`names_to`** Nombre para la nueva variable que se crea a partir de los nombres de cada `cols`

**`values_to`** Nombre para la variable que se crea a partir de los contenidos de cada columna especificada con **`cols`**

## 

```{r}
#| eval: false
#| echo: true

colonias %>%
  pivot_longer(
    cols = c(Abarrotes,Supermercado,Minisuper),
    names_to = "tipo_negocio",
    values_to = "n_negocios")
```

## 

```{r}
colonias %>%
  pivot_longer(
    cols = c(Abarrotes,Supermercado,Minisuper),
    names_to = "tipo_negocio",
    values_to = "n_negocios")
```

## Largo a ancho

```{r}
#| eval: false
#| echo: true

colonias_largo %>% 
  pivot_wider(names_from = tipo_negocio, 
              values_from = n_negocios)
```

**`names_from`** De cu√°les columnas vamos a tomar valores para los nombres de las nuevas variables

**`values_from`** Cu√°l columna tiene los valores de celda para las nuevas variables creadas

## 

```{r}

colonias_largo %>% 
  pivot_wider(names_from = tipo_negocio, 
              values_from = n_negocios)
```

## Ejercicio - pivot {background-color="#a4c5ff"}

-   Carga el archivo "`expresion_genes.csv`". Esta tabla contiene valores de expresi√≥n g√©nica para cinco especies de peces, a partir de muestras tomadas en seis tiempos y de dos tejidos.

-   Transforma los datos de ancho a largo y de regreso a ancho.

# Otras funciones √∫tiles

## 

**`coalesce()`** - Combina valores. A partir de dos o m√°s vectores, retiene valores en orden y rellena datos faltantes con valores de los siguientes vectores.

</br>

**`fill()`** Rellena valores adyacentes. Ayuda a evitar datos faltantes innecesarios. Similar a las funciones para rellenar valores contiguos en hojas de c√°lculo.

## `dplyr::coalesce()`

-   Encuentra y regresa el primer valor que no sea `NA` en cada posici√≥n para un conjunto de vectores

\* *las columnas en datos rectangulares son vectores*

-   Devuelve un solo vector con los valores que no sean `NA` que aparezcan primero.

## 

::: med-code
```{r}
x <- c(1, 2, NA, NA, 5)
y <- c(NA, NA, 3, 4, 5)
z <- c(1, 4, 3, 5, 3)
```
:::

Vectores num√©ricos del mismo largo, hay valores faltantes.

::: big-code
```{r}
coalesce(x, y, z)
```
:::

> El orden de los argumentos importa

## 

::: big-code
```{r}
x <- c(1, 2, NA, NA, 5)
y <- c(NA, NA, 3, 4, 5)
z <- c(1, 4, 3, 5, 3)
```
:::

::: big-code
```{r}
coalesce(z,x,y)
```
:::

## 

```{r}
#| eval: true
#| echo: false

humedad <- 
tibble::tribble(
         ~muestra, ~sensor_1, ~sensor_respaldo, ~literatura,
     "ladera sur",        NA,              4.9,         2.6,
   "ladera norte",       2.2,               NA,         4.3,
         "urbano",       4.5,                5,         3.4,
  "invernadero A",        NA,              2.7,         3.5,
  "invernadero B",       2.5,               NA,         2.3
  )


```

::: panel-tabset
### humedad suelo

```{r}
#| eval: true
#| echo: false
humedad %>% gt() %>% 
    tab_style(
    cell_text(size = '26px'),
    locations = list(cells_body(),
                     cells_column_labels(everything()),
                     cells_title())) %>% 
  tab_options(table.background.color="#f4f4f9")
```

### Datos

```{r}
#| echo: true
#| eval: false

humedad <- 
tibble::tribble(
         ~muestra, ~sensor_1, ~sensor_respaldo, ~literatura,
     "ladera sur",        NA,              4.9,         2.6,
   "ladera norte",       2.2,               NA,         4.3,
         "urbano",       4.5,                5,         3.4,
  "invernadero A",        NA,              2.7,         3.5,
  "invernadero B",       2.5,               NA,         2.3
  )
```
:::

## 

</br>

```{r}
#| eval: true
#| echo: true

humedad %>% 
  mutate(val_completo = coalesce(sensor_1, sensor_respaldo, literatura))
  
```

## `tidyr::fill()`

```{r}
#| echo: false
#| eval: true

carbon_mamiferos <- tibble(mamiferos=c("ganado",NA,NA,NA,NA,"silvestre",NA,NA,NA),
       biomasa=c(21,5,7,23,74,23,65,12,5))
```

::: columns
::: {.column width="40%"}
```{r}
#| echo: false
#| eval: true

carbon_mamiferos %>% gt() %>% 
    tab_style(
    cell_text(size = '21px'),
    locations = list(cells_body(),
                     cells_column_labels(everything()),
                     cells_title())) %>% 
  tab_options(table.background.color="#f4f4f9")
```
:::

::: {.column width="60%"}
-   Rellena valores faltantes en una columna (por defecto de arriba a abajo)

-   Se asume que los valores contiguos son los mismos hasta que aparece otro distinto en la misma columna

-   Rellena hasta el siguiente valor que no sea `NA`
:::
:::

## 

::: columns
::: {.column width="50%"}
```{r}
#| echo: true
#| eval: true
carbon_mamiferos
```
:::

::: {.column width="50%"}
```{r}
#| echo: true
#| eval: true

carbon_mamiferos %>% 
  fill(mamiferos)
```
:::
:::

# Expresiones regulares para trabajar con cadenas de texto

## ¬øExpresiones regulares?

. . .

-   Conocidas como *regex*, R.E., E.R., o *regexp* (singular)

-   Lenguaje conciso para describir patrones de texto

</br>

### Cadenas (üß∂strings) de caracteres codificadas especificamente para empatar patrones en otras cadenas de texto

## Expresiones regulares

En la pr√°ctica, un lenguaje de programaci√≥n con su propia sintaxis y terminolog√≠a

</br>

**entrada:** una cadena de texto que se compila en un mini programa construido espec√≠ficamente para identificar un patr√≥n

</br> Pueden usarse para empatar, buscar, reemplazar, o partir texto

## Cadenas de texto (üß∂Strings)

Un conjunto de caracteres que componen un elemento de un vector:

::: med-code
```{r}
cadena_de_texto <- "Esta oraci√≥n es una cadena"
```
:::

Podemos almacenar varias cadenas en un vector de texto:

::: med-code
```{r}

mascotas <-  c("perro","gato","loro","perro")
```
:::

## Cadenas de texto

::: columns
::: {.column width="50%"}
Los nombres de variables, objetos, y los valores en un data frame tambi√©n pueden ser cadenas de texto:

```{r}
#| eval: true
#| include: false

library(gt)
library(tibble)
library(magrittr)
bebidas_df <- tibble(bebida=c("caf√©","t√©","jugo"),precio=c(3.50,2.99,3.20))
```
:::

::: {.column width="50%"}
```{r}
#| eval: true
#| echo: false

bebidas_df %>%
  gt() %>%
  tab_style(
    style = list(
      cell_fill(color = "yellow"),
       cell_text(size = '35px')
    ),
    locations = cells_body(
      columns = vars(bebida)
    )
  ) %>%
  tab_options(column_labels.background.color = "yellow")
```
:::
:::

## R distingue entre may√∫sculas y min√∫sculas

La misma letra en may√∫scula y min√∫scula se trata como un car√°cter diferente

::: big-code
```{r}
#| eval: true
#| echo: true
"rata"=="RATA"
```

```{r}
#| echo: true
"rata"=="raTa"
```
:::

## Por defecto las expresionas regulares tambi√©n distinguen entre may√∫sculas y m√≠nusculas

Podemos:

-   Construir expresiones que no distingan
-   'Ignorar' esta distinci√≥n al momento de empatar caracteres

## ¬øPara qu√© aprender a escribir expresiones regulares?

. . .

::: incremental
-   Ahorrar tiempo al buscar patrones, transformar texto, describir patrones, extraer partes de palabras, etc.

-   Una sola expresi√≥n regular puede reemplazar decenas de l√≠neas de c√≥digo

-   Sirven en pr√°cticamente cualquier lenguaje de programaci√≥n o aplicaci√≥n de l√≠nea de comandos
:::

## Primeros pasos con regex

::: columns
::: {.column width="33%"}
### Expresi√≥n regular

</br> gato
:::

::: {.column width="33%"}
### Entrada

</br></br> "Ese gato feo"
:::

::: {.column width="33%"}
### Resultado

</br></br> Ese [gato]{style="color: orange"} feo
:::
:::

La expresi√≥n regular para encontrar una secuencia fija de caracteres es esa misma secuencia

> busca una **g** seguida de una **a** luego **t** y **o** (todos estos caracteres juntos y en ese orden de izq. a der.)

## Probando regex

¬øEst√° funcionando mi expresi√≥n?

-   [rubular](https://rubular.com/) - Michael Lovitt

-   [regex101](https://regex101.com/) - Firas Dib

-   [regexr](https://regexr.com/) - Grant Skinner

-   [regexpal](https://www.regexpal.com/) - Dan's Developer Tools

## Ejercicio {background-color="#a4c5ff"}

Abrir [rubular](https://rubular.com/), [regex101](https://regex101.com/), [regexr](https://regexr.com/), o [regexpal](https://www.regexpal.com/)

Probemos el primer ejemplo *gato* y "ese gato feo"

## Caracteres literales y metacaracteres

Tanto las cadenas de texto como las expresiones regulares se componen por caracteres

</br>

Podemos agrupar a los caracteres dependiendo de su comportamiento

## Literales

Si la entrada es **"pato"** y la E.R. es [pato]{style="color: orange"}

</br>

Habr√° coincidencia cuando los caracteres [p]{style="color: orange"}, [a]{style="color: orange"}, [t]{style="color: orange"} y [o]{style="color: orange"} aparezcan consecutivamente en el texto de entrada

## Caracteres literales

[p]{style="color: orange"}, [a]{style="color: orange"}, [t]{style="color: orange"} y [o]{style="color: orange"} ser√≠an ejemplos de caracteres literales

</br> Se encuentran a s√≠ mismos

## 

::: callout-note
## 

El poder y la flexibilidad de las expresiones regulares viene de su capacidad de describir patrones complejos
:::

</br> Si un patr√≥n de texto se puede describir verbalmente, seguramente se puede codificar en una expresi√≥n regular

## Patrones posibles

-   "rata" pero no "bata"

-   "pollo" pero solo si el esta secuencia est√° al principio de la cadena de texto

-   n√∫meros (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)

-   Variantes ortogr√°ficas "Brasil" o "Brazil"

-   Palabras con terminaciones espec√≠ficas (DAE, NAE, etc.)

-   Fechas

-   Correos electr√≥nicos

## M√°s posibilidades

-   C√≥digos postales

-   N√∫meros entre par√©ntesis

-   Usuarios de Twitter/X (comienzan con \@, sin espacios ni s√≠mbolos, \<16 caracteres)

-   Palabras en MAY√öSCULA

## Metacaracteres

Un peque√±o subconjunto de caracteres nos ayudan a describir patrones m√°s complejos porque tienen comportamientos especiales y no se buscan solo a s√≠ mismos.

Cuando aparecen en una E.R., se interpretan de una manera especial.

Incluyen: [\[\]\^\$.\|?\*+()]{style="color: orange"}, que est√°n apartados para fines especiales

## Comodines

Para empatar caracteres desconocidos

**`.`** empata cualquier caracter una vez

</br> [m..l]{style="color: orange"} empata "[miel]{style="background-color: yellow"}" pero no "miguel"

## Conjuntos de caracteres

Empatan uno o m√°s caracteres especificados con corchetes

`[ ]` para buscar conjuntos de caracteres

</br>

[\[mr\]ata]{style="color: orange"} empata "[mata]{style="background-color: yellow"}", y "[rata]{style="background-color: yellow"}", pero no "bata"

## Negando conjuntos de caracteres

[\[\^\]]{style="color: orange"} ¬†¬† excluye conjuntos de caracteres

> `^` va al principio del conjunto

</br>

[\[\^aoeiou\]]{style="color: orange"} solo empata consonantes

[\[\^R\]]{style="color: orange"} todo excepto R may√∫scula

## Intervalos de caracteres

Indican una serie de caracteres contiguos dentro de un conjunto de caracteres

El gui√≥n [-]{style="color: orange"} dentro de un conjunto de caracteres sirve para abreviar secuencias alfab√©ticas o num√©ricas

[\[A-D\]]{style="color: orange"} cualquier letra may√∫scula entre A y D

[\[5-8\]]{style="color: orange"} cualquier d√≠gito entre 5 y 8

[\[A-Za-z\]]{style="color: orange"} cualquier letra

## Aserciones de tipo l√≠mite (anchors)

Especifican la posici√≥n relativa del patr√≥n que estamos buscando

[¬†\^¬†]{style="color: orange"} ¬†¬† comienza con\
[¬†\$¬†]{style="color: orange"} ¬†¬† termina con\

</br>

[¬†¬†\^mil]{style="color: orange"} empata "[mil]{style="background-color: yellow"}itar" pero no "familia"

[ing\$]{style="color: orange"} empata "Bo[ing]{style="background-color: yellow"}" pero no "ingeniero"

## Ejercicio {background-color="#a4c5ff"}

-   ¬øC√≥mo podemos empatar **mano**, **milo**, **malo**, y **mito**?

-   ¬øC√≥mo podemos empatar Cristian, Kristian, y Crystian usando conjuntos de caracteres?

## Pr√°ctica {background-color="#a4c5ff"}

-   ¬øCu√°l de estas E.R. empata **`mila`** al principio de una cadena de texto?

::: columns
::: {.column width="25"}
a)  \^mila
:::

::: {.column width="25"}
b)  mila
:::

::: {.column width="25"}
c)  \$mila
:::

::: {.column width="25"}
d)  mila\^
:::
:::

## Cuantificadores

Indican el n√∫mero de caracteres o expresiones que deben coincidir

[¬†?¬†]{style="color: orange"} ¬†¬†Cero o una\
[¬†\*¬†]{style="color: orange"} ¬†¬†Cero o m√°s\
[¬†+¬†]{style="color: orange"} ¬†¬†Una o m√°s\
[¬†{}]{style="color: orange"} ¬†¬† *n* veces

> los cuantificadores aplican al caracter que tienen a su izquierda

## Cuantificadores

[Isabell?a]{style="color: orange; font-weight: bold"} coincide con "[Isabella]{style="background-color: yellow"}" y con "[Isabela]{style="background-color: yellow"}"

> 0 o 1

[go\*l!]{style="color: orange; font-weight: bold"} coincide con: "[gl!]{style="background-color: yellow"}", "[gol!]{style="background-color: yellow"}", "[gooool!]{style="background-color: yellow"}", "[goooooooool!]{style="background-color: yellow"}", etc.

> 0 o m√°s

## Cuantificadores

[no+]{style="color: orange; font-weight: bold"} empata "[no]{style="background-color: yellow"}", "[nooo]{style="background-color: yellow"}", "[noooooo]{style="background-color: yellow"}", etc, pero no "n"

> una o m√°s

[a{2}]{style="color: orange; font-weight: bold"} empata "port[aa]{style="background-color: yellow"}viones" pero no "portaviones"

> n veces

## Ejercicio {background-color="#a4c5ff"}

-   Empatar **mira**, **miiiiiiiiiira**, y **miiira**

-   Empatar Computador, computadora, computador, y Computadora (usar juegos de caracteres y cuantificadores)

## Coincidencias alternativas

Separa alternativas de b√∫squeda

[¬†\|¬†]{style="color: orange; font-weight: bold"} ¬†¬† una u otra opci√≥n

</br>

[Bra(s\|z)il]{style="color: orange; font-weight: bold"} encuentra Brasil y Brazil.

> las dos alternativas van entre par√©ntesis

## Construcciones especiales y escapes

[¬†\\¬†]{style="color: orange; font-weight: bold"} ¬†¬† indica una construcci√≥n especial abreviada o sirve para poder usar caracteres especiales como literales

## Escapes

[qu√©\\\\?]{style="color: orange; font-weight: bold"} para poder buscar el signo de interrogaci√≥n literalmente

> en R la diagonal tambi√©n se tiene que escapar

*Los metacaracteres dentro de conjuntos de caracteres se vuelven literales*

## Construcciones especiales

Para abreviar conjuntos de caracteres

[\\w]{style="color: orange; font-weight: bold"} ¬†letras, gui√≥n bajo, y n√∫meros

[\\d]{style="color: orange; font-weight: bold"} ¬†d√≠gitos

[\\t]{style="color: orange; font-weight: bold"} ¬†tabulaci√≥n

[\\n]{style="color: orange; font-weight: bold"} ¬† saltos de l√≠nea

[\\s]{style="color: orange; font-weight: bold"} ¬†espacio

[\\b]{style="color: orange; font-weight: bold"} ¬†l√≠mite de palabra

## L√≠mites de palabra

[\\b]{style="color: orange; font-weight: bold"}

Marca la posici√≥n en la que un caracter de palabra (letras, n√∫meros, gui√≥n bajo) no va seguido o precedido por otro caracter de palabra (espacios o el inicio o fin de la cadena)

El l√≠mite de una palabra encontrada no se incluye en el resultado

## L√≠mites de palabra

**Antes de**

[\\bmila]{style="color: orange; font-weight: bold"} encuentra "la [mila]{style="background-color: yellow"}nesa" pero no "Camila"

**Despu√©s de**

[arte\\b]{style="color: orange; font-weight: bold"} encuentra "salud[arte]{style="background-color: yellow"} hoy" pero no "artesanal"

## Ejercicio {background-color="#a4c5ff"}

-   Con la entrada "Los tacos de canasta en Tabasco se abarrotaron"

Expliquemos qu√© pasa cuando usamos estas tres E.R.

a)  ta\
b)  \\bta\
c)  ta\\b

## Combinaciones

[\^can.\*]{style="color: orange; font-weight: bold"} empata "[can]{style="background-color: yellow"}", "[can]{style="background-color: yellow"}ino", "[can]{style="background-color: yellow"}asta", y "[can]{style="background-color: yellow"}adiense"

[A.\*n]{style="color: orange; font-weight: bold"} cualquier cadena de texto que empiece con "**A**" y termine con "**n**"

[\^\[a-z\]+\$]{style="color: orange; font-weight: bold"} solo min√∫sculas

[\\w+\\b\$]{style="color: orange; font-weight: bold"} la √∫ltima palabra en una cadena

"12 de [marzo]{style="background-color: yellow"}"\
"Liomys [pictus]{style="background-color: yellow"}"

[\^\\w+\\b]{style="color: orange; font-weight: bold"} primera palabra "[12]{style="background-color: yellow"} de marzo"\
"[Liomys]{style="background-color: yellow"} pictus"

## Ejercicio {background-color="#a4c5ff"}

Empatemos:

1.  Oraciones que terminen con un punto
2.  Cuatro d√≠gitos
3.  Cadenas sin la letra ***s***

# Expresiones regulares en R

## 

Podemos crear subconjuntos de filas y columnas mediante coincidencias entre expresiones regulares y nombres de variables o con sus valores

## 

![](imgs/regexsubconjuntos.png){fig-align="center"}

## üì¶ `stringr`

Funciones para manipular cadenas de texto

-   Los nombres de las funciones tienen el prefijo **`str_`**

-   El primer argumento de sus funciones es la cadena de texto de inter√©s

-   Funci√≥n **`regex()`** para modificar el comportamiento de b√∫squeda

`ignore_case=TRUE` para dejar de distinguir entre may√∫sculas y min√∫sculas

## `stringr` - ejemplos

**¬øCoincidencias?**

::: med-code
```{r}
#| output-location: slide
str_detect(string = c("catalogo", "aguacate",
"pera"),
 pattern = "cat")
```
:::

Regresa un vector V/F de la misma longitud que la entrada

## `stringr` - m√°s ejemplos

**¬øCu√°les elementos coinciden?**

::: med-code
```{r}
#| output-location: slide
str_which(string = c("catalogo", "aguacate", "pera"), pattern = "cat")
```
:::

Regresa el √≠ndice de los elementos con coincidencias

## `stringr` - reemplazar coincidencias

::: med-code
```{r}

str_replace(string = c("anthonyi", "daviesi", "jonesi"),
            pattern = "i$",
            replacement = "ii")
```
:::

## `stringr` - funci√≥n `regex()`

**Sin distinci√≥n entre MAYUSCULAS y min√∫sculas**

```{r}


str_replace(string = c("anthonyI", "daviesi", "jonesi"),
            pattern = regex("i$",ignore_case = TRUE),
            replacement = "ii")
```

## Ejercicio - `stringr` {background-color="#a4c5ff"}

Probemos estas expresiones contra este vector usando `str_detect`. Explicar las coincidencias.

E. regulares

1.  \^ave\
2.  \^\[a-z\]+\$\
3.  \\d

```{r}
#| echo: true
#| eval: false

vec_texto <- c("Aves y reptiles","hamburguesa",
                 "34","(34)","rAta","avenida",
                 "2011_julio","inecol","INECOL")
```

## Manipulando datos con expresiones regulares

</br>

Elegir/descartar filas y columnas

Reemplazar o modificar valores

Extraer o borrar partes de cadenas de texto

## Expresiones regulares y üì¶ `dplyr`

</br>

La funci√≥n auxiliar **`matches()`** acepta expresiones regulares para seleccionar variables que contengan coincidencias

## Seleccionando variables

Datos de ping√ºinos `pinguinos` de üì¶ `datos`

::: med-code
```{r}
library(datos)
names(pinguinos)
```
:::

## 

::: med-code
```{r}
pinguinos %>% 
  select(especie, matches("larg")) %>% 
  sample_n(3)
```
:::

## Filtrando filas

Datos de pa√≠ses del paquete üì¶ `datos`

```{r, eval=FALSE}
library(datos)
data(paises)
```

::: med-code
```{r}
paises %>% select(pais,continente) %>% 
  sample_n(4)
```
:::

## Coincidencias en filas

Pa√≠ses con "z" en su nombre

```{r}
#| eval: true
#| echo: true
paises %>% select(pais,continente) %>% 
  filter(str_detect(pais,"z")) %>% 
  distinct()
```

# Informaci√≥n repetida

## Valores repetidos

-   Definici√≥n variable pero generalmente dos o m√°s copias del mismo registro u observaci√≥n

### Problemas posibles

-   Inflan datos

-   Costos de repetici√≥n no intencional

-   Resultados imprecisos

## Identificando y eliminando duplicados

-   Identificar con `get_dupes()` del paquete üì¶ `janitor`

-   Eliminar con `distinct()` de üì¶ `dplyr`

## Repetici√≥n

-   En todas las variables (copias id√©nticas de una fila)

-   En las variables que definen nuestras unidades observacionales

-   En conjuntos arbitrarios de variables

## 

::: panel-tabset
### ordenes_pizza

```{r}
#| eval: true
#| echo: false

tibble::tribble(
    ~IDusuario,            ~Direccion,    ~Colonia,    ~Alcaldia,
    "Pablitoo",  "Cafetal 395 Casa 2", "San Angel", "A. Obreg√≥n",
    "susana24",         "Fresnos 114", "San Angel", "A. Obreg√≥n",
    "susana24",         "Fresnos 114", "San Angel", "A. Obreg√≥n",
  "jd.adriana",  "Cafetal 395 Casa 8", "San Angel", "A. Obreg√≥n",
  "JuanManuel", "Hidalgo 11 Depto 1B", "Campestre", "A. Obreg√≥n",
   "JoaquinED", "Hidalgo 11 Depto 1B", "Campestre", "A. Obreg√≥n",
      "e_ric2", "Hidalgo 11 Depto 1B", "Campestre", "A. Obreg√≥n"
  ) %>% 
  gt() %>%
  tab_style(
    cell_text(size = "26px"),
    locations = list(
      cells_body(),
      cells_column_labels(everything()),
      cells_title()
    )
  )

```

### datos

```{r}
#| eval: true
#| echo: true

ordenes_pizza <- 
tibble::tribble(
    ~IDusuario,            ~Direccion,    ~Colonia,    ~Alcaldia,
    "Pablitoo",  "Cafetal 395 Casa 2", "San Angel", "A. Obreg√≥n",
    "susana24",         "Fresnos 114", "San Angel", "A. Obreg√≥n",
    "susana24",         "Fresnos 114", "San Angel", "A. Obreg√≥n",
  "jd.adriana",  "Cafetal 395 Casa 8", "San Angel", "A. Obreg√≥n",
  "JuanManuel", "Hidalgo 11 Depto 1B", "Campestre", "A. Obreg√≥n",
   "JoaquinED", "Hidalgo 11 Depto 1B", "Campestre", "A. Obreg√≥n",
      "e_ric2", "Hidalgo 11 Depto 1B", "Campestre", "A. Obreg√≥n"
  )
```
:::

## Identificar con `get_dupes()`

```{r}
ordenes_pizza %>%
  get_dupes() # todas las variables (por defecto)
```

-   A√±ade una variable `dupe_count` que cuantifica las filas con valores duplicados

-   Acomoda las variables de inter√©s al principio del data frame resultante

## 

`get_dupes()` asignando una variable para definir nuestra unidad observacional

¬øAlguien orden√≥ m√°s de una vez?

```{r}
ordenes_pizza %>%
  get_dupes(IDusuario)
```

## 

`get_dupes()` con combinaciones de variables

-   Filas repetidas en direcci√≥n \* colonia

> accepta funciones auxiliares de üì¶ `tidyselect`

```{r}
ordenes_pizza %>%
  get_dupes(Direccion, starts_with("Col"))
```

## 

Descartar con `distinct()` de üì¶ `dplyr`

. . .

```{r}
ordenes_pizza %>%
  distinct() # todas las variables
```

## 

`distinct()` con la variables que definen las unidades observacionales

```{r}
ordenes_pizza %>%
  distinct(IDusuario, .keep_all = TRUE)
```

> `.keep_all` para retener o no las dem√°s columnas

## 

`distinct()` con combinaciones de variables

-   Combinaciones √∫nicas de direcci√≥n \* colonia

```{r, eval=TRUE}
ordenes_pizza %>%
  distinct(Direccion,Colonia)
```

## 

> ‚ö†Ô∏è Si `.keep_all = TRUE` y hay valores duplicados en otras variables, `distinct` solo retiene la primera fila

```{r}
ordenes_pizza %>%
  distinct(Direccion,Colonia, .keep_all = TRUE)
```

## Ejercicio {background-color="#a4c5ff"}

-   Cargar el archivo `murcielagos.csv`

-   ¬øDe cu√°ntas localidades √∫nicas provienen estos registros?

-   Exportar un archivo con las localidades √∫nicas y nombres de columna en espa√±ol

# ¬°Listo!